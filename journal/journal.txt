SEMAINE 1
Jour 1 : lecture 2 papier, 1 papier sur comment on utilise le code INPOP pour les ephemerides plnetaires et pour les asteroide, comment on determine leur taille, masse, rayon etc
un autre papier sur la doc de BVLS, ecrit en fortran qui est un element principale du code de calcul et qu'il faudrait donc acccelerer d'une maniere ou d'une autre. debut de la prise em main du code, tentative de le faire fonctionner avec des entree de base avant de pouvoir voir comment ameliorer tout ca
Jour 2 : En cours de faire fonctionner le code avec le K1 restreint, setup des parametres, remise a niveau en fortran, indexisation commence a 1 /!\ lire dans des fichiers avec fortran est complique. Interface main-BVLS fonctionne pour le K1, debut d'optimisations. Passage dans maqao, petites ameliorations dans la facon dont c'est compile. attention a bien mettre la bonne archi. en changeant la ligne de commande de simple a optimise, on gagne 50% de perf deja. maintenant je vais vraiment rentrer
dans le code pour voir les boucles et vectoriser tout ca, il me faut l'architecture calculateur cyble. attention a bien retirer les print de M et N dans BVLS, ca ralentit vachement les affichages. on peut aller encore plus loin avec -0fast, mais il faudrait que je soit capable de faire des tests de qualite de resultat pour voir si -ofast est envisageable. le code est tres bien ecrit, les boucles sont propres, pas d'interdependance et pour pouvoir gerer la vectorisation il me faut des
spec du calculateur cyble. demain je vais faire des recherches sur des methodes d'invertions de matrice et essayer de passer ce code fortran degueu en C, c'est seulement 500 lignes et c'est plutot aere donc ca devrait etre bon. Rapport de maqao a la fin de la journe dans ce dossier.
Jour 3 : ouverture avec ssh, transfert de fichiers. Debut des informations sur les specs de la machine de run , on a 128 Go en tout et 25Mo de cache par coeur. Il va falloir prendre en compte cela lorsque je vais mettre em place la vecto du code fortran. projet de passage en C abandonne pour le moment, pas tres utile et ca va prendre du temps. attention aussi aux changement que ca impliquera de modifier les codes qui y sont lier, I/O. Aujourd'hui, focus sur la vecto. Avant de vectoriser
des boucles il faudrais que je connaisse leurs poids dans la fonction et laquelle est a ameliorer en priorite. De plus, le code est ecrit de maniere elegante et deja optimise, il n'y a vraiment que l'utilisation de la vecto a mettre en place ou bien de chercher un algo completement different afin de changer de methode d'inversion. tentavie de maqao + oneview pour connaitre les points chaud mais ca fonctionne tjr pas a cause de mon proc non reconnue .. anyway, time for
recherche de methodes d'inversion de matrice, et ensuite tester des les implementer. Il faudrait que je sache si c'est vraiment utile d'inverser la matrice ou si il est possible de plutot trouver une alternative ou un calcul equivalent qui n'implique pas d'inverser une matrice. la matrice est elle creuse ? restricturation des donne, lineariser la matrice ? a approfondir. Update : la lecture dans les fichier ne se faisait pas, je lisais que des 0 partout je vais devoir reprendre
la facon dont je lis dans un fichier en fortran. Erreur de debutant, probleme d'indicage de fichier d'ouverture + probleme de lecture avec attribution foireuse de la lacture dans un array. avant de finir aujourd'hui je vais mettre en place la verification du X generer avec le X de reference dans RAW_20.out. le rapport maaqao/cqa du 24 mars ne sert a rien, on essayant avec oneview ca marche quand meme pas donc ....
Jour 4 : gros probleme d'IO encore c'est regle pour de bon, je fais face a des problemes de taille de vecteurs et de matrice, j'ai le code d'erreur IEER = 2 ce qui veux dire que ca il y a des problemes de taille ou de forme dans B X BND W ou INDEX. Work in progress. Probleme de taille regle, maintenant je suis en train d'essayer de regler un probleme de passage d'arguments qui deconnent entre mon main et la subroutine, B(1) n'est pas le meme dans les 2 sections. Rien ne fonctionne
aujourd'hui, le transfert d'arguments du main au code BVLS, le transfer sur gpm du fichier de demonstration, le syke ne marche pas non plus .. pas bcp de progret et bcp de temps passe a faire des trucs qui marchent pas. Apres avoir pu recuperer le bout de code d'exemple de l'utilisation du BVLS j'ai pu comprendre comment passer des matrices et vecteurs en arguments d'une fonction. Il faut, comme en cm passer par des pointeur que l'on envoi. J'ai donc un code qui des des resulats.
faux, peut etre, car different des resultats auxquelles je dois comparer, mais les bonne valeurs sont en entree entout cas. Le resultat est completement fuax, le chi2 creve le plafond a 1200 alors que je devrais tomber sur 8.5e-3 encore du travaille a fournir pour comprendre comment ca marche et surtout arriver a manipuler correctement les matrices et le foprtran pour tomber sir ce que je suis cense tomber.
JOUR 5 : Je reprends ou je m'etais arrete hier, l'utilisation des matrices et vecteurs d'entree est bonne, les IO sont bon et pourtant l'output de X ne colle pas a la demo et le chi2 est bcp trop eleve. Pour le chi2 donc le code exemple je vois que c'est divise par une valeur avant d'etre affichee, je ne le divise pas, peut etre une source de difference, mais ca n'explique pas le diff dans le vecteur X. Comme si il faisait des calculs different alors qu'il est cense avoir la meme
entree de donnee. Tout simplement les indices de l'affichage des resultats etait decale de 1 a cause que la premiere ligne du fichier de verification contient le chi2 de comparaison. Pour la valeur du chi2, il est normalise par le degre de liberte du systeme etudie, donc ici il faut le diviser par 141970 et miracle on tombe sur la bonne valeur. Maintenant commence le vrai travaille d'analyse, on va commencer par utiliser les options de compile pour voir si ca peut changer des
choses, puis regarder comment vectoriser les boucles et enfin on pourra essayer d'autres algos de resolution de probleme. Aucun changement entre ifort et ifort -O3. ifort compile deja le programme avec le maximum d'optimisations possible. j'ai tente d'analyser le programme avec maqao sur mon ordi perso mais encore une fois, proc non reconnue et je ne peut pas avoir le rapport des boucles du programmes, ce qui est bien dommage. Je sais avec gprof qu'evidement je passe beaucoup de temps
dans BVLS et principalement dans 2 fonctions de la boucle principale. je vais essayer de mettre en place de la vectorisation au niveau de ces boucles fonctions la. dans leur boucles qui sont elle meme repetee. overall la subroutine bvls est bien optimisee pour du fortran et a par hardcoder la vecto, il n'y aurait plus qu'a changer de methode d'inversion ou de resolution de systemem lineaire pour pouvoir ameliorer. Profillage reussi avec maqao lprof suivit d'une commande d'analyse des donnees de sortie pour l'afficher proprement en html, commandes :
maqao lprof ./a.out --use-OS-timers
pour profiler le code
maqao lprof -dl -df of=html xp=<nom du fichier output de haut dessus>
pour creer un html lisible qu'il faut ensuite ouvrir.
Voir le rapport maqao du 27 mars a cote pour comprendre la suite des analyses (l'ancien rapport cqa inutile a ete suppr)
Il faurdra re profiler en profillant les fonctions et les loops, ca fera 2 rapports different mais ca devrait etre good.


SEMAINE 2
JOUR 6 : Retour apres week end, le code est ope a etre ameliore, premiere opti serait de vectoriser les boucles en prenant en compte la taille des caches. A priori la RAM sera suffisante pour tout garder en memoire a la fois. Mise en pratique de la vecto apres analyse plus profonde avec maqao est les boucles. essai rate de remplacement des boucles, 2eme essai en cours, a un endroit le remplacement a errone les resultats. La methodes devrai etre bonne, surement erreur d'indice
quelque part, recommence en prenant soit de verifier chaque etape. je repoars de git log <go>. Apres avoir remplace toute les boucles implicites par des boucles explicites, aucune difference notable dans les perf, le compilo ne vectorise toujours pas, il va falloir retravailler les boucles et surement chercher des options de compilation pour le forcer a faire ce qu'om veut
JOUR 7 : Le deroulage des boucles implicites a degrade les perfs un petit peu, time for vecto. Avec ifort l'option -unroll-and-jam n'existe pas apparement et pareil pour -march=<archi> il ignore ces options et les considere comme inconnues. Petit tests de vectorisation concluants, debut d'implementation dans le code. Apres avoir mis en place une gestion a la main de la vectorisertion je tombe a des performances de ~10000 ticks par exec, ce qui est tres similaires aux perfs de
depart. A vrai dire on pourrait appeler ca "aucun changement" je vais verifier avec maqao
JOUR 8 : BVLS arrive a la fin de son "amelioration" aucun changement concret n'a ete capable de modifier durablement et positivement les perfs de la sbroutine. idee d'agnes : changer l'unite des elements a manipuler pour peut etre gagner des perfs sur le type a manipuler lors du calcul, pas sur mais essai en cours. Apres ca il y a LSVCE a developper avec la decomposition LU a l'interieur.
JOUR 9 : travail sur lsvce, apres avoir debugger les erreurs de segmentation a cause d'allocations, le code met ~234 000 cycles a s'executer sur gpm. time pour l'upgrade. a premiere vue il y a deja quelques boucles qui vont pouvoir etre amelioree, changer l'ordre des incides etc. aussi tenter -O3 ca mange pas de pain.
ifort -heap-arrays lsvce.f90 -g -traceback -check all -fp-stack-check : 234 000 cycles
ifort -lsvce.f90 -O3/-Ofast -funroll-loop : 17 000 cycles
Petite reunion de fin de journee, mes propositions d'opti sont comprises et vont etre etudiees. Pendant ce temps je recupere plus de travaille a faire d'elements sur lesquels me pencher, voir tdl.txt a cote. Probleme avec openMP sur 2 petits tests ca fonctionne tres bien mais avec le code bvls, probleme, on dirait qu'un seul thread omp est utilisee, a changer.
JOUR 10 : (oublie de report)

SEMAINE 3
JOUR 11 : (oublie de report)
JOUR 12 : suite a la reunion de lundi, debut du travaille d'analyse de la matrice pour cette semaine, voir comment on pourrait mettre certaines zones a 0 ou la correlation est nul, donc les elements de la matrice peuvent etre retires. Ensuite il faudra voir comment changer la forme de la matrice pour tirer des perfs de la forme aqu'elle a. Apres la colonne 62, la matrice d'entree A est tres creuse, mais tout remplacer par 0 induit des changement dans le calcul de X non negligeable (a
    verifier) Pour y remedier il faut jeter un oeil a la matrice de correlation.

Semaine ? jour ? 17/04
optimisation de lsvce.f90, linearisation de matrice, optimisations de calculs et de gestion memoire, implementation d'openmp dans les boucles a sommes et les calculs simples. Il faudrait se pencher sur les calculs involvant NN5 qui prennent passe de temps

20/04 :
Mise en place du makefile, travail sur la parallelisation des elements lourds de lsvce. TODO, generaliser le code de lsvce avec plus que une decomposition en 2, essayer de mettre en place possibilitee de decomposition en n
22/04 :lsvce avec fortran est a son pic de performances, avec 17 sec/iter au lieux de ~4 minutes, next step : ajouter MPI et generaliser le probleme.

28/04 :
Abandon du projet de biblio MPI+openmp de calcul matriciel, accumulation de processes MPI inutiles, mieux d'utiliser openmp seulement. retour sur bvls et etude de la forme de la matrice, dependances, covariances etc
