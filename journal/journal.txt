Jour 1 : lecture 2 papier, 1 papier sur comment on utilise le code INPOP pour les ephemerides plnetaires et pour les asteroide, comment on determine leur taille, masse, rayon etc
un autre papier sur la doc de BVLS, ecrit en fortran qui est un element principale du code de calcul et qu'il faudrait donc acccelerer d'une maniere ou d'une autre. debut de la prise em main du code, tentative de le faire fonctionner avec des entree de base avant de pouvoir voir comment ameliorer tout ca
Jour 2 : En cours de faire fonctionner le code avec le K1 restreint, setup des parametres, remise a niveau en fortran, indexisation commence a 1 /!\ lire dans des fichiers avec fortran est complique. Interface main-BVLS fonctionne pour le K1, debut d'optimisations. Passage dans maqao, petites ameliorations dans la facon dont c'est compile. attention a bien mettre la bonne archi. en changeant la ligne de commande de simple a optimise, on gagne 50% de perf deja. maintenant je vais vraiment rentrer
dans le code pour voir les boucles et vectoriser tout ca, il me faut l'architecture calculateur cyble. attention a bien retirer les print de M et N dans BVLS, ca ralentit vachement les affichages. on peut aller encore plus loin avec -0fast, mais il faudrait que je soit capable de faire des tests de qualite de resultat pour voir si -ofast est envisageable. le code est tres bien ecrit, les boucles sont propres, pas d'interdependance et pour pouvoir gerer la vectorisation il me faut des
spec du calculateur cyble. demain je vais faire des recherches sur des methodes d'invertions de matrice et essayer de passer ce code fortran degueu en C, c'est seulement 500 lignes et c'est plutot aere donc ca devrait etre bon. Rapport de maqao a la fin de la journe dans ce dossier.
Jour 3 : ouverture avec ssh, transfert de fichiers. Debut des informations sur les specs de la machine de run , on a 128 Go en tout et 25Mo de cache par coeur. Il va falloir prendre en compte cela lorsque je vais mettre em place la vecto du code fortran. projet de passage en C abandonne pour le moment, pas tres utile et ca va prendre du temps. attention aussi aux changement que ca impliquera de modifier les codes qui y sont lier, I/O. Aujourd'hui, focus sur la vecto. Avant de vectoriser
des boucles il faudrais que je connaisse leurs poids dans la fonction et laquelle est a ameliorer en priorite. De plus, le code est ecrit de maniere elegante et deja optimise, il n'y a vraiment que l'utilisation de la vecto a mettre en place ou bien de chercher un algo completement different afin de changer de methode d'inversion. tentavie de maqao + oneview pour connaitre les points chaud mais ca fonctionne tjr pas a cause de mon proc non reconnue .. anyway, time for
recherche de methodes d'inversion de matrice, et ensuite tester des les implementer. Il faudrait que je sache si c'est vraiment utile d'inverser la matrice ou si il est possible de plutot trouver une alternative ou un calcul equivalent qui n'implique pas d'inverser une matrice. la matrice est elle creuse ? restricturation des donne, lineariser la matrice ? a approfondir. Update : la lecture dans les fichier ne se faisait pas, je lisais que des 0 partout je vais devoir reprendre
la facon dont je lis dans un fichier en fortran. Erreur de debutant, probleme d'indicage de fichier d'ouverture + probleme de lecture avec attribution foireuse de la lacture dans un array. avant de finir aujourd'hui je vais mettre en place la verification du X generer avec le X de reference dans RAW_20.out. le rapport maaqao/cqa du 24 mars ne sert a rien, on essayant avec oneview ca marche quand meme pas donc ....
Jour 4 : gros probleme d'IO encore c'est regle pour de bon, je fais face a des problemes de taille de vecteurs et de matrice, j'ai le code d'erreur IEER = 2 ce qui veux dire que ca il y a des problemes de taille ou de forme dans B X BND W ou INDEX. Work in progress. Probleme de taille regle, maintenant je suis en train d'essayer de regler un probleme de passage d'arguments qui deconnent entre mon main et la subroutine, B(1) n'est pas le meme dans les 2 sections. Rien ne fonctionne
aujourd'hui, le transfert d'arguments du main au code BVLS, le transfer sur gpm du fichier de demonstration, le syke ne marche pas non plus .. pas bcp de progret et bcp de temps passe a faire des trucs qui marchent pas. Apres avoir pu recuperer le bout de code d'exemple de l'utilisation du BVLS j'ai pu comprendre comment passer des matrices et vecteurs en arguments d'une fonction. Il faut, comme en cm passer par des pointeur que l'on envoi. J'ai donc un code qui des des resulats.
faux, peut etre, car different des resultats auxquelles je dois comparer, mais les bonne valeurs sont en entree entout cas. Le resultat est completement fuax, le chi2 creve le plafond a 1200 alors que je devrais tomber sur 8.5e-3 encore du travaille a fournir pour comprendre comment ca marche et surtout arriver a manipuler correctement les matrices et le foprtran pour tomber sir ce que je suis cense tomber.
JOUR 5 : Je reprends ou je m'etais arrete hier, l'utilisation des matrices et vecteurs d'entree est bonne, les IO sont bon et pourtant l'output de X ne colle pas a la demo et le chi2 est bcp trop eleve. Pour le chi2 donc le code exemple je vois que c'est divise par une valeur avant d'etre affichee, je ne le divise pas, peut etre une source de difference, mais ca n'explique pas le diff dans le vecteur X. Comme si il faisait des calculs different alors qu'il est cense avoir la meme
entree de donnee. Tout simplement les indices de l'affichage des resultats etait decale de 1 a cause que la premiere ligne du fichier de verification contient le chi2 de comparaison. Pour la valeur du chi2, il est normalise par le degre de liberte du systeme etudie, donc ici il faut le diviser par 141970 et miracle on tombe sur la bonne valeur. Maintenant commence le vrai travaille d'analyse, on va commencer par utiliser les options de compile pour voir si ca peut changer des
choses, puis regarder comment vectoriser les boucles et enfin on pourra essayer d'autres algos de resolution de probleme. Aucun changement entre ifort et ifort -O3. ifort compile deja le programme avec le maximum d'optimisations possible. j'ai tente d'analyser le programme avec maqao sur mon ordi perso mais encore une fois, proc non reconnue et je ne peut pas avoir le rapport des boucles du programmes, ce qui est bien dommage. Je sais avec gprof qu'evidement je passe beaucoup de temps
dans BVLS et principalement dans 2 fonctions de la boucle principale. je vais essayer de mettre en place de la vectorisation au niveau de ces boucles fonctions la. dans leur boucles qui sont elle meme repetee. overall la subroutine bvls est bien optimisee pour du fortran et a par hardcoder la vecto, il n'y aurait plus qu'a changer de methode d'inversion ou de resolution de systemem lineaire pour pouvoir ameliorer. Profillage reussi avec maqao lprof suivit d'une commande d'analyse des donnees de sortie pour l'afficher proprement en html, commandes :
maqao lprof ./a.out --use-OS-timers
pour profiler le code
maqao lprof -dl -df of=html xp=<nom du fichier output de haut dessus>
pour creer un html lisible qu'il faut ensuite ouvrir.
Voir le rapport maqao du 27 mars a cote pour comprendre la suite des analyses (l'ancien rapport cqa inutile a ete suppr)
Il faurdra re profiler en profillant les fonctions et les loops, ca fera 2 rapports different mais ca devrait etre good
